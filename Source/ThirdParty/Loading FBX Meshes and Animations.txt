Model* ModelFactory::LoadModelFBXSDK(std::wstring someFilePath)
{
    // This is optional, you can just use normal strings. I like widechar
    // but the FBX SDK doesn't understand it. Watch out for swedish characters
    // in the path!!!
    const std::string ansiFileName = DB::string_cast<std::string>(someFilePath);

    // The vertices we'll be using.
    std::vector<Vertex> mdlVertices;

    // And our indices to these vertices.
    std::vector<unsigned int> mdlIndices;
    
    // Skeleton data if we have bones.
    Skeleton mdlSkeleton;
    // We need to know this for later processing.
    bool hasBones = false;

    // This should probably live in the class and be reused.
    // Saves on allocation and memory.
    // The FBX Manager handles various internal things for the rest of the
    // FBX SDK system when in use.
    FbxManager* myFBXManager = FbxManager::Create();
    FbxImporter* fbxImporter = FbxImporter::Create(myFBXManager, "");

    // Load the file and make sure it's a valid FBX file.
    assert(fbxImporter->Initialize(ansiFileName.c_str(), -1, myFBXManager->GetIOSettings()));
    assert(fbxImporter->IsFBX());

    // Things in the FBX file live in a scene which we need to work with.
    FbxScene* fbxScene = FbxScene::Create(myFBXManager, "The Scene");

    // This fixes the winding, and converts properly.
    // Changes -Z forward to +Z forward.
    // Flips Z on Normals, Binormals and Tangents.
    // Changes UV 1,1 from top right to bottom right.
    FbxAxisSystem fbxAxisSystem(FbxAxisSystem::eDirectX);
    fbxAxisSystem.ConvertScene(fbxScene);

    // I use this to keep track of the bone ID and Weights per Control Point.
    // (What a control point is we'll get to in a minute).
    std::unordered_multimap<unsigned int, std::pair<size_t, float>> ControlPointWeights;

    // Try to import the FBX file into the scene we've specified.
    if(fbxImporter->Import(fbxScene))
    {
        // First we triangulate the scene we've imported.
        // We always want to work with triangles whenever possible.
	    FbxGeometryConverter fbxConverter(myFBXManager);
        fbxConverter.Triangulate(fbxScene, true);

        // The FBX file format is a giant hierarchy of nodes.
        // They can be anything that the software supports and
        // this means that they are not only meshes! Right now
        // we just need all the meshes.
        // Therefore we go through the scene and find all meshes.
        std::vector<FbxNode*> mdlMeshNodes;
        GatherFBXMeshes(fbxScene->GetRootNode(), mdlMeshNodes);

        // For animations we need skeleton data so look for a skeleton and gather
        // all the joints that make up said skeleton.
        hasBones = GatherSkeletonData(fbxScene->GetRootNode(), mdlSkeleton, 0, 0);

        // And then we load all meshes.
        // 
        // CAVEAT: This should be split into separate Mesh class objects for real world applications.
        // Otherwise rendering might be weird. Or at least have an index buffer with offsets
        // and make sure you offset the vertices in the vxbuffer too.
        //
        for(FbxNode* mdlMeshNode : mdlMeshNodes)
        {
            // Since this is from GatherFBXMeshes we know that it's an FbxMesh.
            // That means that this shouldn't result in nullptr.
	        FbxMesh* fbxMesh = mdlMeshNode->GetMesh();

            // Check if we have bones. If we do we need to gather binding information.
            if (hasBones)
            {
                // Load the FBX root transform. This is something provided by the modeling software.
                // All we need to do is assemble it.
                const FbxVector4 fbxTranslation = mdlMeshNode->GetGeometricTranslation(FbxNode::eSourcePivot);
                const FbxVector4 fbxRotation = mdlMeshNode->GetGeometricRotation(FbxNode::eSourcePivot);
                const FbxVector4 fbxScale = mdlMeshNode->GetGeometricScaling(FbxNode::eSourcePivot);
                const fbxsdk::FbxAMatrix rootTransform = FbxAMatrix(fbxTranslation, fbxRotation, fbxScale);

                // The FBX world has many different kinds of deformers. They can be skeleton bones but
                // they can also be several other things such as forces, effects, scripts, what not.
                for (int deformIdx = 0; deformIdx < fbxMesh->GetDeformerCount(); deformIdx++)
                {
                    // We only care about Skins, i.e. the method that binds a mesh to a skeleton.
                    FbxSkin* fbxSkin = reinterpret_cast<FbxSkin*>(fbxMesh->GetDeformer(deformIdx, FbxDeformer::eSkin));

                    // So if it's not a skin keep looking. You probably want a warning here if a model
                    // has a skeleton but it's not bound!
                    if (!fbxSkin)
                        continue;

                    // The Skin deform is made up out of skin clusters. These are for all intents
                    // and purposes the joints that affect that section of the skin.
                    for (int clusterIdx = 0; clusterIdx < fbxSkin->GetClusterCount(); clusterIdx++)
                    {
                        // So we go through each cluster.
                        FbxCluster* fbxCluster = fbxSkin->GetCluster(clusterIdx);

                        // We get the transform of the cluster that was present at skin binding time.
                        // This is the "resting pose" if you like.
                        fbxsdk::FbxAMatrix meshBindTransform;
                        fbxCluster->GetTransformMatrix(meshBindTransform);

                        // We also need the link transform. In the case of a Skin it will be the
                        // transform to go from local Joint Space to World Space.
                        fbxsdk::FbxAMatrix linkTransform;
                        fbxCluster->GetTransformLinkMatrix(linkTransform);
                        
                        // And finally assemble the Bind Pose Transform.
                        // This is the default position of the vertices.
                        fbxsdk::FbxAMatrix bindPoseInverseTransform = linkTransform.Inverse() * meshBindTransform * rootTransform;
                        // Remember to do this or you will get very interesting results :).
                        bindPoseInverseTransform = bindPoseInverseTransform.Transpose();

                        // The Link in the skin cluster is the actual joint.
                        // Because we already collected all joints we should be able to find it using
                        // the acceleration map in the Skeleton.
                        size_t jointIndex = mdlSkeleton.JointNameToIndex[fbxCluster->GetLink()->GetName()];
                        
                        // Store the bind pose on the joint so we can access it later.
                        mdlSkeleton.Joints[jointIndex].BindPoseInverse = DB::ConvertFBXMatrix(bindPoseInverseTransform);

                        // Here comes some more control point stuff.
                        // We need to collect all the control points that this skin cluster affects.
                        // And for those we need to store which joint affects it and its weights.
                        for (int i = 0; i < fbxCluster->GetControlPointIndicesCount(); i++)
                        {
                            unsigned int c = fbxCluster->GetControlPointIndices()[i];
                            float w = static_cast<float>(fbxCluster->GetControlPointWeights()[i]);
                            // This inserts into a multimap.
                            // c - control point index.
                            // jointIndex - self explanatory.
                            // w - the weight for this joint.
                            ControlPointWeights.insert({ c, { jointIndex, w }});
                        }

                        // While we're at it we can read FBX animation data here.
                        // Because you'll probably end up reading files differently in your engine
                        // this is important to think about later.
                        // You probably don't want to read vertices and weights from animation files
                        // and just bother with the transforms. I do this here because this is an
                        // example and it's less for you to navigate.

                        // TGA SA bake their FBX animations when they export. This means that the
                        // animation data is stored _per frame_ instead. Essentially every frame
                        // is a keyframe. This means that it's much easier to interact with than
                        // the AssImp keys.
                        
                        // We'll load the first animation stack. Since we use Maya or Motion Builder it's
                        // always 0.
                        FbxAnimStack* fbxAnimStack = fbxScene->GetSrcObject<FbxAnimStack>(0);

                        // We get the name of it since Motion Builder can have several.
                        FbxString animStackName = fbxAnimStack->GetName();
                        std::string animationName = animStackName.Buffer();

                        // Then we load the Take for this animation. This can only be a single one in Maya
                        // but Motion Builder can have several! There's no standard at TGA saying we should
                        // support multiple right now, though. Check with the animators!
                        FbxTakeInfo* fbxTakeInfo = fbxScene->GetTakeInfo(animStackName);
                        if (fbxTakeInfo)
                        {
                            // We need the start of the animation take.
                            FbxTime fbxAnimStart = fbxTakeInfo->mLocalTimeSpan.GetStart();
                            // And the end as well.
                            FbxTime fbxAnimEnd = fbxTakeInfo->mLocalTimeSpan.GetStop();

                            // You can find out the duration of this animation in frames by asking the SDK to convert for you.
                            // I convert to 24 FPS animation here but there are several different ones you can use.
                            // Remember to +1 since we want the final frame too!
                            FbxLongLong animTime = fbxAnimEnd.GetFrameCount(FbxTime::eFrames24) - fbxAnimStart.GetFrameCount(FbxTime::eFrames24) + 1;

                            // I store my animation directly in the joints. This is also not really that
                            // useful in a production environment such as your game engines. It just
                            // makes this easier to implement and look at! :).
                            // It also doesn't cover the VG part of having blended animations.
                            mdlSkeleton.Joints[jointIndex].Animation.resize(animTime + 1);

                            // Regardless we step through the animation frames and evaluate the animation transforms for each frame.
                            for(FbxLongLong t = fbxAnimStart.GetFrameCount(FbxTime::eFrames24); t <= fbxAnimEnd.GetFrameCount(FbxTime::eFrames24); t++)
                            {
	                            FbxTime currentTime;
                                currentTime.SetFrame(t, FbxTime::eFrames24);

                                // We evaluate the joint transform for this keyframe.
                                FbxAMatrix nodeTransform = mdlMeshNode->EvaluateGlobalTransform(currentTime) * rootTransform;
                                FbxAMatrix frameTransform = nodeTransform.Inverse() * fbxCluster->GetLink()->EvaluateGlobalTransform(currentTime);

                                // Remember to transpose it.
                                frameTransform = frameTransform.Transpose();

                                // Then store the resulting animation transform for this particular frame in the joint that owns it.
                                mdlSkeleton.Joints[jointIndex].Animation[t] = DB::ConvertFBXMatrix(frameTransform);
                            }

                            // We CAN also read per curve but this is a bit more tricky.
                            // Presently TGA SA also don't export with curves but bake animations.
                            // Baked animations makes the FBX format generate per-frame transforms.
                            //int nbAnimLayers = currAnimStack->GetMemberCount<FbxAnimLayer>();
                            //for (int l = 0; l < nbAnimLayers; l++)
                            //{
	                           // FbxAnimLayer* fbxAnimLayer = currAnimStack->GetMember<FbxAnimLayer>(l);
                            //    FbxAnimCurve* fbxAnimCurve = mdlMeshNode->LclTranslation.GetCurve(fbxAnimLayer, FBXSDK_CURVENODE_TRANSLATION);
                            //    if(fbxAnimCurve)
                            //    {
	                           //     int animKeyCount = fbxAnimCurve->KeyGetCount();
                            //        for(int k = 0; k < animKeyCount; k++)
                            //        {
	                           //         FbxAnimCurveKey fbxKey = fbxAnimCurve->KeyGet(k);
                            //            float keyValue = fbxKey.GetValue();
                            //            FbxTime keyTime = fbxKey.GetTime();
                            //            double seconds = keyTime.GetSecondDouble();

                            //            std::cout << keyValue << seconds << std::endl;
                            //        }
                            //    }
                            //}
                        }
                    }
                }
            }

            // That is all for animation data! Now we have everything we need to animate the mesh!
            // Yay.
            // But we need to read the mesh data too!

			// If our mesh doesn't have any binormals or tangents we need to calculate them.
			if(fbxMesh->GetElementBinormalCount() == 0 || fbxMesh->GetElementTangentCount() == 0)
			{
			    bool result = fbxMesh->GenerateTangentsData(0, true, false);
			    assert(result);
			}

            // FBX Meshes are stored with control points. A control point != vertex.
            // It is, instead, a bit more complicated, it's still a point in the mesh
            // but it only has location information.
            // 
            // A vertex is a point that has UVs, Normals, Tangents, etc.
            // To create a vertex we need the location of the control point and the
            // data that is required to create a specific vertex for a specific polygon.

            // To get this we need to read the mesh Per Vertex, Per Polygon.
            const int fbxMeshPolygonCount = fbxMesh->GetPolygonCount();
            for(int p = 0; p < fbxMeshPolygonCount; p++)
            {
                // Since we triangulated we know how many vertices we have per polygon.
                for(int v = 0; v < 3; v++)
                {
                    // Get the vertex at this index in this polygon. This yields the
                    // control point index we need to read data from.
	                const int fbxControlPtIndex = fbxMesh->GetPolygonVertex(p, v);

                	// And then get the control point that correspond to that polygon vertex.
                    // The control point is just a position. Keep in mind that w=0 here!
                    // That is not what it should be in our vectors.
                    const FbxVector4 fbxVxPos = fbxMesh->GetControlPointAt(fbxControlPtIndex);

                    // Load all the UV sets for this vertex. We support up to 4 of them.
                	FbxVector2 fbxVxUVs[4];
                    const int fbxNumUVs = fbxMesh->GetElementUVCount();
                    // We need to know which UV index to read data from and we can easily
                    // get that using the polygon and vertex of that polygon.
                    const int fbxTextureUVIndex = fbxMesh->GetTextureUVIndex(p, v);
                    for(int uv = 0; uv < fbxNumUVs && uv < 4; uv++)
                    {
	                    FbxGeometryElementUV* fbxUvElement = fbxMesh->GetElementUV(uv);
						fbxVxUVs[uv] = fbxUvElement->GetDirectArray().GetAt(fbxTextureUVIndex);
                    }

                    // Loading normals and so on requires the same (p, v) indexes but there
                    // are no functions that work like that. So instead we concatenate
                    // the values.
                    const int polygonIndex = p * 3 + v;

                    // We get the normals for this polygon vertex.
                    FbxVector4 fbxNormal;
                    FbxGeometryElementNormal* fbxNormalElement = fbxMesh->GetElementNormal(0);
                    auto mapMode = fbxNormalElement->GetMappingMode(); // eByPolygonVertex
                    assert(mapMode == 2);
                    auto refMode = fbxNormalElement->GetReferenceMode(); // eDirect
                    assert(refMode == 0);
                    fbxNormal = fbxNormalElement->GetDirectArray().GetAt(polygonIndex);

                    // And the tangents.
                    FbxVector4 fbxTangent;
                    FbxGeometryElementTangent* fbxTangentElement = fbxMesh->GetElementTangent(0);
                    fbxTangent = fbxTangentElement->GetDirectArray().GetAt(polygonIndex);

                    // The Biormals
                    FbxVector4 fbxBinormal;
                    FbxGeometryElementBinormal* fbxBinormalElement = fbxMesh->GetElementBinormal(0);
                    fbxBinormal = fbxBinormalElement->GetDirectArray().GetAt(polygonIndex);

                    // And the vertex colors. We support 4 here too.
                    FbxColor fbxColors[4];
                    const int fbxNumVxColorChannels = fbxMesh->GetElementVertexColorCount();
                    for(int col = 0; col < fbxNumVxColorChannels && col < 4; col++)
	                {
		                FbxGeometryElementVertexColor* colElement = fbxMesh->GetElementVertexColor(col);
                        fbxColors[col] = colElement->GetDirectArray().GetAt(polygonIndex);
	                }

                    // During the animation load we created that multimap with ControlPoint to Weight data.
                    // Now it's time to put that to use so we can store it in the vertices!                    
                    unsigned int BoneIDs[] = {0, 0, 0, 0};
                    float BoneWeights[] = { 0, 0, 0, 0};
                    // Get animation weight data
                    if(hasBones)
                    {
                        // Since we're making a bit of a complex iteration we need to define the iterator.
                        // It's a lot less to type that way.
                        typedef std::unordered_multimap<unsigned int, std::pair<size_t, float>>::iterator MMIter;

                        // Then we use equal range to get all the data stored for this specific control point.
                        std::pair<MMIter, MMIter> values = ControlPointWeights.equal_range(fbxControlPtIndex);

                        // This idx is to loop on the 4 indices of ID and Weight.
                        int idx = 0;
                        for(MMIter it = values.first; it != values.second && idx < 4; ++it)
                        {
	                        std::pair<size_t, float> BoneAndWeight = it->second;
                            BoneIDs[idx] = BoneAndWeight.first;
                            BoneWeights[idx] = BoneAndWeight.second;
                        	idx++;
                        }
                    }

                    // Assemble the Vertex.
                    Vertex vx = 
                    {
                        static_cast<float>(fbxVxPos[0]),
                        static_cast<float>(fbxVxPos[1]),
                        static_cast<float>(fbxVxPos[2]),
                        static_cast<float>(fbxNormal[0]),
                        static_cast<float>(fbxNormal[1]),
                        static_cast<float>(fbxNormal[2]),
                        static_cast<float>(fbxTangent[0]),
                        static_cast<float>(fbxTangent[1]),
                        static_cast<float>(fbxTangent[2]),
                        static_cast<float>(fbxBinormal[0]),
                        static_cast<float>(fbxBinormal[1]),
                        static_cast<float>(fbxBinormal[2]),
                        static_cast<float>(fbxColors[0][0]),
                        static_cast<float>(fbxColors[0][1]),
                        static_cast<float>(fbxColors[0][2]),
                        static_cast<float>(fbxColors[0][3]),
                        static_cast<float>(fbxVxUVs[0][0]),
                        static_cast<float>(fbxVxUVs[0][1])
                    };

                    vx.BoneIDs = { BoneIDs[0], BoneIDs[1], BoneIDs[2], BoneIDs[3] };
                    vx.BoneWeights = { BoneWeights[0], BoneWeights[1], BoneWeights[2], BoneWeights[3] };

                    // A drawback of using control points is that we MAY get duplicate vertices.
                    // This means we'll need to compare and ensure that it is a unique vert.
                    // The only way to do that is to compare all data.
                    bool alreadyExists = false;
                    for(size_t i = 0; i < mdlVertices.size(); i++)
                    {
                        // This is Vertex::operator==. It runs a memcmp(A, B, size) == 0
                        // which works well for Plain Old Data (POD) objects.
	                    if(mdlVertices[i] == vx)
	                    {
                            // If the vertex already existed we just store its index.
		                    mdlIndices.push_back(static_cast<unsigned int>(i));
                            alreadyExists = true;
                            break;
	                    }
                    }

                    // If this is a new vertex we need to store it and its index.
                    if(!alreadyExists)
                    {
	                    mdlVertices.push_back(vx);
                        mdlIndices.push_back(static_cast<unsigned int>(mdlVertices.size() - 1));
                    }
                }
            }
        }
    }

    // Below here it's just as in the lectures. We load the textures, create vx buffer, etc.